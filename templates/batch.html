<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Joblication - Batch Processing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            --primary-dark: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            --primary-color: #1e40af;
            --primary-dark-color: #0f172a;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --pending: #3b82f6;
            --bg-light: #f9fafb;
            --border: #e5e7eb;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-bottom: 30px;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: var(--shadow);
        }
        
        .card-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            height: 24px;
            line-height: 1;
        }
        
        .card-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark-color));
            border-radius: 2px;
        }
        
        /* Left Column - Input */
        .input-section {
            margin-top: 16px;
        }
        
        .input-section textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
            white-space: pre;
            overflow-x: auto;
        }
        
        .input-section textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
        }
        
        .url-counter {
            margin: 12px 0;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark-color));
            color: white;
            flex: 1;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(30, 64, 175, 0.3);
        }
        
        .btn-secondary {
            background: var(--bg-light);
            color: var(--text-primary);
            border: 2px solid var(--border);
            flex: 0 1 auto;
        }
        
        .btn-secondary:hover {
            background: white;
            border-color: var(--primary-color);
        }
        
        .btn-warning {
            background: #f59e0b;
            color: white;
            border: 2px solid #f59e0b;
            flex: 0 1 auto;
        }
        
        .btn-warning:hover {
            background: #d97706;
            border-color: #d97706;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Progress Section */
        .progress-section {
            margin-top: 25px;
            padding-top: 25px;
            border-top: 2px solid var(--border);
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .progress-info strong {
            color: var(--text-primary);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-light);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--primary-dark-color));
            transition: width 0.3s ease;
            width: 0%;
        }
        
        /* Queue Table */
        .queue-table-wrapper {
            margin-top: 20px;
            max-height: 450px;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
        }
        
        .queue-table-wrapper::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .queue-table-wrapper::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
        }
        
        .queue-table-wrapper::-webkit-scrollbar-thumb {
            background: rgba(30, 64, 175, 0.3);
            border-radius: 10px;
        }
        
        .queue-table-wrapper::-webkit-scrollbar-thumb:hover {
            background: rgba(30, 64, 175, 0.5);
        }
        
        .queue-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        
        .queue-table thead {
            background: var(--bg-light);
            border-bottom: 2px solid var(--border);
            position: sticky;
            top: 0;
        }
        
        .queue-table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            vertical-align: middle;
        }
        
        .queue-table td {
            padding: 12px;
            vertical-align: middle;
            display: table-cell;
            border-top: 1px solid var(--border);
        }
        
        .queue-table tbody tr:first-child td {
            border-top: none;
        }
        
        .queue-table tbody tr:hover {
            background: var(--bg-light);
        }
        
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.85em;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .status-badge.completed {
            background: rgba(34, 197, 94, 0.1);
            color: var(--success);
        }
        
        .status-badge.processing {
            background: rgba(30, 64, 175, 0.1);
            color: var(--pending);
        }
        
        .status-badge.queued {
            background: rgba(107, 114, 128, 0.1);
            color: var(--text-secondary);
        }
        
        .status-badge.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }
        
        .status-badge.cover_letter_failed {
            background: rgba(245, 158, 11, 0.1);
            color: #f59e0b;
        }
        
        .status-badge.cancelled {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            font-weight: 700;
        }
        
        .status-badge.duplicate {
            background: rgba(245, 158, 11, 0.1);
            color: #f59e0b;
        }
        
        .status-badge.duplicate::before {
            content: '';
            display: none;
        }
        
        .status-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        
        .actions {
            display: flex;
            gap: 8px;
            justify-content: flex-start;
            white-space: nowrap;
            flex-wrap: nowrap;
            align-items: center;
        }
        
        .action-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            font-size: 0.85em;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s;
            border: none;
            background: none;
            cursor: pointer;
        }
        
        .action-link:hover {
            background: rgba(30, 64, 175, 0.1);
            text-decoration: underline;
        }
        
        .action-link.download::before {
            content: '‚¨á ';
        }
        
        .action-link.trello::before {
            content: 'üîó ';
        }
        
        .action-link.retry {
            color: #f59e0b;
        }
        
        .action-link.retry:hover {
            background: rgba(245, 158, 11, 0.1);
        }
        
        .action-link.delete {
            color: #6b7280;
        }
        
        .action-link.delete:hover {
            background: rgba(107, 114, 128, 0.1);
        }
        
        /* Table links */
        .table-link {
            color: var(--primary-color);
            text-decoration: none;
            cursor: pointer;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }
        
        .table-link:hover {
            color: var(--primary-dark);
            border-bottom-color: var(--primary-color);
        }
        
        /* Right Column - Results */
        .results-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        
        .stat-card {
            background: var(--bg-light);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid var(--border);
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            border-color: var(--primary-color);
            background: white;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .stat-number.success {
            color: var(--success);
        }
        
        .stat-number.warning {
            color: var(--warning);
        }
        
        .stat-number.error {
            color: var(--error);
        }
        
        .stat-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .recent-files {
            background: var(--bg-light);
            border-radius: 8px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .recent-files-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
        }
        
        .file-item {
            padding: 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 4px solid var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }
        
        .file-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .file-info {
            flex: 1;
        }
        
        .file-name {
            font-weight: 500;
            font-size: 0.9em;
            color: var(--text-primary);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-time {
            font-size: 0.8em;
            color: var(--text-secondary);
        }
        
        .file-download {
            color: var(--primary-color);
            cursor: pointer;
            text-decoration: none;
            font-weight: 600;
            margin-left: 10px;
            transition: all 0.3s;
        }
        
        .file-download:hover {
            color: var(--primary-dark);
        }
        
        .view-all-link {
            display: block;
            text-align: center;
            margin-top: 15px;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 600;
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s;
        }
        
        .view-all-link:hover {
            background: rgba(30, 64, 175, 0.1);
        }
        
        /* Settings Section */
        .settings-card {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            flex-shrink: 0;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 30px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }
        
        .settings-header:hover {
            background-color: rgba(30, 64, 175, 0.03);
        }
        
        .settings-toggle {
            font-size: 1.2em;
            color: var(--primary-color);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px;
            line-height: 1;
        }
        
        .settings-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 30px 30px 30px;
        }
        
        .settings-content.collapsed {
            max-height: 0;
            padding: 0 30px;
        }
        
        .settings-header.collapsed .settings-toggle {
            transform: rotate(-90deg);
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }
        
        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .checkbox-group label {
            flex: 1;
            cursor: pointer;
            font-weight: 500;
        }
        
        .settings-label {
            font-weight: 600;
            font-size: 0.95em;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .settings-group select {
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .settings-group select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-state-text {
            font-size: 1.1em;
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .summary-stats {
                grid-template-columns: 1fr;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 640px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .card {
                padding: 20px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn-primary {
                flex: 1;
            }
            
            .queue-table {
                font-size: 0.8em;
            }
            
            .queue-table th,
            .queue-table td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Joblication</h1>
            <p>Batch Process ‚Ä¢ Organize ‚Ä¢ Generate ‚Ä¢ Apply</p>
        </div>
        
        <div class="main-grid">
            <!-- Left Column: Input & Queue -->
            <div class="card">
                <div class="card-title">Job URLs</div>
                
                <div class="input-section">
                    <textarea id="urlInput" placeholder="Paste Stepstone or LinkedIn job URLs here (one per line)"></textarea>
                    <div class="url-counter">
                        <span id="urlCount">0</span> URLs entered
                    </div>
                    
                    <div class="button-group">
                        <button class="btn btn-primary" id="processAllBtn" onclick="processAllJobs()">
                            ‚ñ∂ Process All Jobs
                        </button>
                        <button class="btn btn-secondary" id="clearAllBtn" onclick="clearInput()">Clear All</button>
                        <button class="btn btn-danger" id="stopAllBtn" onclick="cancelAll()" style="display: none;">
                            ‚èπ Stop All
                        </button>
                    </div>
                </div>
                
                <!-- Progress Section -->
                <div class="progress-section" id="progressSection" style="display: none;">
                    <div class="progress-info">
                        <strong>Job <span id="jobsProcessing">0</span> of <span id="jobsTotal">0</span></strong>
                        <span><span id="progressPercent">0</span>%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" id="progressBar"></div>
                    </div>
                    <div class="progress-step-indicator" id="progressStep" style="margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); font-weight: 500;">
                        Gathering information...
                    </div>
                </div>
                
                <!-- Queue Table -->
                <div id="queueTableContainer" class="queue-table-wrapper" style="display: none;">
                    <table class="queue-table">
                        <thead>
                            <tr>
                                <th>Job Title</th>
                                <th>Company</th>
                                <th>Status</th>
                                <th>Actions</th>
                                <th>Delete</th>
                            </tr>
                        </thead>
                        <tbody id="queueTableBody">
                        </tbody>
                    </table>
                </div>
                
                <!-- Empty Queue State -->
                <div class="empty-state" id="emptyQueueState">
                    <div class="empty-state-icon">üìã</div>
                    <div class="empty-state-text">No jobs in queue yet. Paste URLs above to get started.</div>
                </div>
            </div>
            
            <!-- Right Column: Results & Files -->
            
        </div>
        
        <!-- Settings Section -->
        <div class="settings-card">
            <div class="settings-header collapsed" onclick="toggleSettings(this)">
                <div class="card-title">‚öôÔ∏è Settings</div>
                <span class="settings-toggle">‚ñº</span>
            </div>
            
            <div class="settings-content collapsed">
                <div class="settings-grid">
                    <div class="settings-group">
                        <!-- 1. Create Trello Cards -->
                        <div class="checkbox-group" style="margin-top: 8px;">
                            <input type="checkbox" id="createTrelloCheckbox" checked>
                            <label for="createTrelloCheckbox">Create Trello Cards</label>
                        </div>
                        
                        <!-- 2. AI generated Cover Letter Heading -->
                        <div style="margin-top: 20px; margin-bottom: 8px;">
                            <strong style="display: block;">AI generated Cover Letter</strong>
                        </div>
                        
                        <!-- 3. Generate Word Cover Letter (aligned with heading) -->
                        <div class="checkbox-group" style="margin-left: 0px; margin-bottom: 6px;">
                            <input type="checkbox" id="generateDocumentsCheckbox" checked>
                            <label for="generateDocumentsCheckbox">Generate Cover Letter (MS Word)</label>
                        </div>
                        
                        <!-- 4. Optional: Save as PDF (indented 20px from Generate) -->
                        <div class="checkbox-group" id="pdfCheckboxGroup" style="margin-left: 20px; margin-bottom: 8px;">
                            <input type="checkbox" id="generatePdfCheckbox">
                            <label for="generatePdfCheckbox">Optional: Save as .pdf</label>
                        </div>
                        
                        <!-- 5. Language Model Dropdown (aligned with Generate Cover Letter) -->
                        <div style="margin-left: 0px; margin-bottom: 8px;">
                            <label for="llmSelect" style="display: block; margin-bottom: 4px; font-size: 0.95em;">Language model:</label>
                            <select id="llmSelect">
                                <option value="gpt-4o-mini">GPT-4o Mini (Fast, Affordable)</option>
                                <option value="gpt-4o">GPT-4o (Best Quality)</option>
                                <option value="claude-3-5-sonnet" disabled>Claude 3.5 Sonnet (Coming soon)</option>
                                <option value="claude-3-haiku" disabled>Claude 3 Haiku (Coming soon)</option>
                                <option value="gemini-1.5-flash" disabled>Gemini 1.5 Flash (Coming soon)</option>
                                <option value="gemini-1.5-pro" disabled>Gemini 1.5 Pro (Coming soon)</option>
                            </select>
                        </div>
                        
                        <div id="validationMessage" style="color: #ef4444; font-size: 0.9em; margin-top: 12px; display: none;">
                            ‚ö†Ô∏è Select at least one option above
                        </div>
                    </div>
                    
                    <div class="settings-group">
                        <label class="settings-label">Language</label>
                        <select id="languageSelect">
                            <option value="auto">Auto-detect</option>
                            <option value="de">Deutsch</option>
                            <option value="en">English</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // State management
        let queue = [];
        let processing = false;
        let currentBatchId = null;  // Track the current batch of jobs
        let results = {
            completed: 0,
            errors: 0,
            files: []
        };
        
        // Processing steps constants
        const PROCESSING_STEPS = {
            'scraping': { label: 'Gathering information...', percent: 0 },
            'trello': { label: 'Logging in Trello...', percent: 20 },
            'cover_letter': { label: 'Generating cover letter...', percent: 60 },
            'documents': { label: 'Creating documents...', percent: 80 },
            'complete': { label: 'Complete!', percent: 100 }
        };
        
        // Current processing info
        let currentJobStep = 'scraping';
        
        // Initialize event listeners after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Count URLs
            document.getElementById('urlInput').addEventListener('input', function() {
                const urls = this.value.trim().split('\n').filter(url => url.trim().length > 0);
                document.getElementById('urlCount').textContent = urls.length;
            });
        });
        
        // Paste from clipboard
        async function pasteFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('urlInput').value = text;
                document.getElementById('urlInput').dispatchEvent(new Event('input'));
            } catch (err) {
                alert('Failed to read clipboard');
            }
        }
        
        // Clear input
        function clearInput() {
            // Clear only the URL input field, not the job queue
            document.getElementById('urlInput').value = '';
        }
        
        // Pause is currently not functional - backend is blocking during process_job_posting
        // TODO: Implement proper pause by refactoring main.py to support pause checking
        function togglePause() {
            // Disabled for now - pause doesn't work while backend is busy
            alert('Pause functionality requires backend refactoring. Use Cancel All instead.');
        }
        
        // Cancel all jobs
        async function cancelAll() {
            if (!confirm('Are you sure you want to cancel all processing? (Processing jobs will be marked as cancelled)')) {
                return;
            }
            
            processing = false;
            paused = false;
            
            // Mark currently processing and queued jobs as cancelled
            queue.forEach(job => {
                if (job.status === 'processing' || job.status === 'queued') {
                    job.status = 'cancelled';
                }
            });
            
            try {
                const response = await fetch('/cancel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    console.log('Processing cancelled - jobs marked as cancelled');
                }
            } catch (error) {
                console.error('Error cancelling jobs:', error);
            }
            
            // Reset UI (keep URLs in input field, keep queue in display with cancelled badges)
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('processAllBtn').disabled = false;
            document.getElementById('stopAllBtn').style.display = 'none';
            document.getElementById('clearAllBtn').style.display = 'inline-block';
            updateQueueDisplay();
            loadRecentFiles();
        }
        
        // Process all jobs
        function processAllJobs() {
            try {
                const urlInput = document.getElementById('urlInput');
                
                if (!urlInput) {
                    alert('ERROR: urlInput element not found!');
                    return;
                }
                
                const inputValue = urlInput.value;
                const urls = inputValue.trim().split('\n').filter(url => url.trim().length > 0);
                
                if (urls.length === 0) {
                    alert('Please paste job URLs first');
                    return;
                }
                
                // Get processing options
                const createTrello = document.getElementById('createTrelloCheckbox').checked;
                const generateDocuments = document.getElementById('generateDocumentsCheckbox').checked;
                const generatePdf = document.getElementById('generatePdfCheckbox').checked;
                
                // Validate: at least one option must be selected
                if (!createTrello && !generateDocuments) {
                    const validationMsg = document.getElementById('validationMessage');
                    if (validationMsg) {
                        validationMsg.style.display = 'block';
                    }
                    alert('Please select at least one processing option:\n- Create Trello Cards\n- Generate Documents');
                    return;
                }
                
                // Hide validation message if showing
                const validationMsg = document.getElementById('validationMessage');
                if (validationMsg) {
                    validationMsg.style.display = 'none';
                }
                
                console.log('Processing ' + urls.length + ' URLs with options:', { createTrello, generateDocuments, generatePdf });
            
            const targetLanguage = document.getElementById('languageSelect').value;
            
            // Create a new batch ID
            currentBatchId = `batch_${Date.now()}`;
            
            // Create new job entries
            const newJobs = urls.map((url, index) => ({
                id: `job_${Date.now()}_${index}`,
                url: url.trim(),
                status: 'queued',
                title: 'Loading...',
                company: 'Loading...',
                message: 'Queued...',
                progress: 0,
                batchId: currentBatchId,  // Mark which batch this job belongs to
                // Store processing options with each job
                createTrello: createTrello,
                generateDocuments: generateDocuments,
                generatePdf: generatePdf,
                targetLanguage: targetLanguage
            }));
            
            // Append new jobs to existing queue instead of replacing it
            queue = queue.concat(newJobs);
            
            processing = true;
            results.completed = 0;
            results.errors = 0;
            updateStats();
            updateQueueDisplay();
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('processAllBtn').disabled = true;
            document.getElementById('clearAllBtn').style.display = 'none';
            document.getElementById('stopAllBtn').style.display = 'inline-block';
            
            console.log('Starting to process', queue.length, 'jobs');
            processNextJob();
            } catch (error) {
                console.error('processAllJobs error:', error);
            }
        }
        
        // Process next job
        async function processNextJob() {
            const job = queue.find(j => j.status === 'queued');
            
            if (!job) {
                console.log('No more queued jobs, processing complete');
                processing = false;
                document.getElementById('processAllBtn').disabled = false;
                document.getElementById('clearAllBtn').style.display = 'inline-block';
                document.getElementById('stopAllBtn').style.display = 'none';
                loadRecentFiles(); // Final refresh after all jobs done
                return;
            }
            
            console.log('Processing job:', job.url);
            
            job.status = 'processing';
            updateQueueDisplay();
            updateProgressBar();
            
            try {
                // Use settings stored with the job
                const payload = { 
                    url: job.url,
                    create_trello_card: job.createTrello,
                    generate_documents: job.generateDocuments,
                    generate_pdf: job.generatePdf,
                    target_language: job.targetLanguage
                };
                
                console.log('Processing job with options:', payload);
                
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                console.log('Response status:', response.status);
                
                const data = await response.json();
                
                console.log('Response data:', data);
                
                if (data.error) {
                    job.status = 'error';
                    job.error = data.error;
                    results.errors++;
                    updateStats();
                    updateQueueDisplay();
                    processNextJob();
                } else {
                    job.jobId = data.job_id;
                    // Poll immediately a few times to grab early scrape data (job title & company)
                    // before the regular 1s polling interval kicks in
                    pollForEarlyData(job);
                }
            } catch (error) {
                console.error('Error processing job:', error);
                job.status = 'error';
                job.error = error.message;
                results.errors++;
                updateStats();
                updateQueueDisplay();
                processNextJob();
            }
        }
        
        // Poll immediately for early data (job title & company from early scrape)
        // This is aggressive polling to catch the data as soon as it's available
        async function pollForEarlyData(job) {
            let attempts = 0;
            const maxAttempts = 15; // Poll for up to ~1.5 seconds
            
            const earlyPoll = setInterval(async () => {
                attempts++;
                try {
                    const response = await fetch(`/status/${job.jobId}`);
                    const data = await response.json();
                    
                    // Check if we got the early data
                    if (data.job_title && data.job_title !== '' && job.title === 'Loading...') {
                        job.title = data.job_title;
                        job.company = data.company_name || 'Unknown';
                        console.log(`‚úì Early data grabbed at attempt ${attempts}: ${job.company} - ${job.title}`);
                        updateQueueDisplay();
                    }
                    
                    // After we have the data or max attempts, switch to normal polling
                    if ((data.job_title && data.job_title !== '') || attempts >= maxAttempts) {
                        clearInterval(earlyPoll);
                        checkJobStatus(job); // Switch to normal polling
                        return;
                    }
                } catch (error) {
                    console.error('Early poll error:', error);
                    if (attempts >= maxAttempts) {
                        clearInterval(earlyPoll);
                        checkJobStatus(job); // Fallback to normal polling
                    }
                }
            }, 100); // Poll every 100ms for the first 1.5 seconds
        }
        
        // Check job status
        async function checkJobStatus(job) {
            try {
                const response = await fetch(`/status/${job.jobId}`);
                
                // If job was cancelled (404), stop polling
                if (response.status === 404) {
                    console.log(`[${job.id}] Job not found (404) - stopping polling`);
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`[${job.id}] Status:`, data); // DEBUG
                
                if (data.status === 'complete') {
                    job.status = 'completed';
                    job.title = data.result.title || 'Unknown';
                    job.company = data.result.company || 'Unknown';
                    job.result = data.result;
                    // Preserve duplicate flag if already set (don't overwrite on retry)
                    job.isDuplicate = job.isDuplicate || data.result.is_duplicate || false;
                    job.progress = 100; // Mark as 100% complete
                    results.completed++;
                    updateStats();
                    updateQueueDisplay();
                    updateProgressBar();
                    processNextJob();
                } else if (data.status === 'error') {
                    job.status = 'error';
                    job.error = data.message;
                    results.errors++;
                    updateStats();
                    updateQueueDisplay();
                    updateProgressBar();
                    processNextJob();
                } else if (data.status === 'cover_letter_failed') {
                    // NEW: Handle cover letter failure - allow retry
                    job.status = 'cover_letter_failed';
                    job.title = data.result.title || 'Unknown';
                    job.company = data.result.company || 'Unknown';
                    job.result = data.result;
                    job.isDuplicate = data.result.is_duplicate || false;
                    job.progress = 100;
                    job.message = data.message || 'Cover letter failed - click retry';
                    results.errors++;
                    updateStats();
                    updateQueueDisplay();
                    updateProgressBar();
                    processNextJob();
                } else {
                    job.progress = data.progress || 0;
                    job.message = data.message || 'Processing...';
                    // Update title and company as soon as they're available (during early scrape)
                    // Only update if we currently have "Loading..." placeholder
                    if (data.job_title && job.title === 'Loading...') {
                        job.title = data.job_title;
                    }
                    if (data.company_name && job.company === 'Loading...') {
                        job.company = data.company_name;
                    }
                    // Also update URLs as soon as they're available (during early scrape)
                    if (data.source_url) {
                        job.source_url = data.source_url;
                    }
                    if (data.company_page_url) {
                        job.company_page_url = data.company_page_url;
                    }
                    updateQueueDisplay();
                    updateProgressBar();
                    setTimeout(() => checkJobStatus(job), 1000);
                }
            } catch (error) {
                console.error('Error checking status:', error);
                setTimeout(() => checkJobStatus(job), 2000);
            }
        }
        
        // Update queue display
        function updateQueueDisplay() {
            const tbody = document.getElementById('queueTableBody');
            const emptyState = document.getElementById('emptyQueueState');
            const tableContainer = document.getElementById('queueTableContainer');
            
            tbody.innerHTML = '';
            
            if (queue.length === 0) {
                tableContainer.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }
            
            tableContainer.style.display = 'block';
            emptyState.style.display = 'none';
            
            queue.forEach(job => {
                const row = document.createElement('tr');
                
                // Build status HTML with optional duplicate warning
                let statusHTML = `<span class="status-badge ${job.status}">
                    ${job.status === 'cover_letter_failed' ? 'Cover Letter Failed' : job.status.charAt(0).toUpperCase() + job.status.slice(1)}
                </span>`;
                
                if (job.isDuplicate) {
                    statusHTML += ` <span class="status-badge duplicate" title="This job posting was already processed before">‚ö†Ô∏è Duplicate</span>`;
                }
                
                row.innerHTML = `
                    <td>
                        ${job.source_url || job.result?.source_url ? `<a href="${job.source_url || job.result?.source_url}" target="_blank" class="table-link" title="Open job description">${job.title}</a>` : `${job.title}`}
                    </td>
                    <td>
                        ${job.company_page_url || job.result?.company_page_url ? `<a href="${job.company_page_url || job.result?.company_page_url}" target="_blank" class="table-link" title="Open company page">${job.company}</a>` : `${job.company}`}
                    </td>
                    <td style="display: flex; gap: 8px; align-items: center; flex-wrap: nowrap; min-width: 220px;">
                        ${statusHTML}
                    </td>
                    <td class="actions">
                        ${job.status === 'completed' ? `
                            ${job.result?.files?.docx ? `<a href="/download/${job.result.files.docx}" download class="action-link download">Word</a>` : `<span class="action-link download" style="opacity: 0.4; cursor: not-allowed; pointer-events: none;">Word</span>`}
                            ${job.result?.files?.pdf ? `<a href="/download/${job.result.files.pdf}" target="_blank" class="action-link download">PDF</a>` : `<span class="action-link download" style="opacity: 0.4; cursor: not-allowed; pointer-events: none;">PDF</span>`}
                            ${job.result?.trello_card ? `<a href="${job.result.trello_card}" target="_blank" class="action-link trello">Trello</a>` : `<span class="action-link trello" style="opacity: 0.4; cursor: not-allowed; pointer-events: none;">Trello</span>`}
                        ` : job.status === 'cover_letter_failed' ? `
                            <button class="action-link retry" onclick="retryCoverLetter('${job.jobId}')">üîÑ Retry</button>
                        ` : job.status === 'error' ? `<span style="color: #ef4444; font-size: 0.85em;">Failed</span>` : ''}
                    </td>
                    <td>
                        <button class="action-link delete" onclick="deleteJob('${job.jobId}')">üóëÔ∏è Delete</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // Retry cover letter generation
        function retryCoverLetter(jobId) {
            if (!confirm('Retry cover letter generation?')) return;
            
            // Find the job in queue
            const job = queue.find(j => j.jobId === jobId);
            if (!job) {
                alert('Job not found in queue');
                return;
            }
            
            fetch(`/retry-cover-letter/${jobId}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    console.log('Cover letter retry started');
                    // Resume polling for this job
                    job.status = 'processing';
                    job.progress = 60;
                    job.message = 'Generating Cover Letter with AI (Retry)';
                    updateQueueDisplay();
                    updateProgressBar();
                    // Restart polling
                    checkJobStatus(job);
                } else {
                    alert('Error: ' + (data.error || 'Failed to start retry'));
                }
            })
            .catch(err => {
                console.error('Retry failed:', err);
                alert('Error: ' + err.message);
            });
        }
        
        // Delete job
        function deleteJob(jobId) {
            if (!jobId || jobId === 'undefined') {
                alert('Error: Job ID is invalid');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this job?')) {
                return;
            }
            
            // Remove the job from the queue
            const jobIndex = queue.findIndex(j => j.jobId === jobId);
            if (jobIndex !== -1) {
                queue.splice(jobIndex, 1);
                updateQueueDisplay();
            }
            
            fetch(`/delete/${jobId}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    alert('Error: ' + (data.error || 'Failed to delete job'));
                }
            })
            .catch(err => {
                console.error('Delete failed:', err);
                alert('Error: ' + err.message);
            });
        }
        
        // Toggle Settings panel
        function toggleSettings(headerElement) {
            const content = headerElement.nextElementSibling;
            headerElement.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        }
        
        // Update progress bar
        function updateProgressBar() {
            // Only count jobs from the current batch
            const batchJobs = queue.filter(j => j.batchId === currentBatchId);
            const total = batchJobs.length;
            const completed = batchJobs.filter(j => j.status === 'completed').length;
            const processingJob = batchJobs.find(j => j.status === 'processing');
            
            // Show job count (e.g., "Job 1 of 3")
            const currentJobNum = completed + (processingJob ? 1 : 0);
            document.getElementById('jobsProcessing').textContent = currentJobNum;
            document.getElementById('jobsTotal').textContent = total;
            
            // Progress bar shows the CURRENT JOB'S progress (0-100%)
            const jobProgress = processingJob ? (processingJob.progress || 0) : (completed > 0 ? 100 : 0);
            document.getElementById('progressPercent').textContent = jobProgress;
            document.getElementById('progressBar').style.width = jobProgress + '%';
            
            // Update step indicator based on currently processing job
            updateProgressStepIndicator();
        }
        
        // Update progress step indicator
        function updateProgressStepIndicator() {
            const processingJob = queue.find(j => j.status === 'processing');
            
            if (!processingJob) {
                document.getElementById('progressStep').textContent = 'Ready to process...';
                currentJobStep = 'scraping';
                return;
            }
            
            // Use the message from the backend (backend provides the current step)
            // Backend sends: 'Gathering Information', 'Creating Trello Card', 'Generating Cover Letter with AI', 'Creating Word document', 'Saving PDF'
            const backendMessage = processingJob.message || 'Processing...';
            document.getElementById('progressStep').textContent = backendMessage;
            
            // Update currentJobStep for any legacy code that may need it
            if (backendMessage.includes('Gathering')) {
                currentJobStep = 'scraping';
            } else if (backendMessage.includes('Trello')) {
                currentJobStep = 'trello';
            } else if (backendMessage.includes('Cover Letter')) {
                currentJobStep = 'cover_letter';
            } else if (backendMessage.includes('Word') || backendMessage.includes('document')) {
                currentJobStep = 'documents';
            } else if (backendMessage.includes('PDF')) {
                currentJobStep = 'pdf';
            }
        }
        
        // Update stats
        function updateStats() {
            // Stats elements were removed in UI redesign - this is now optional
            const statLetters = document.getElementById('statLetters');
            const statCards = document.getElementById('statCards');
            const statErrors = document.getElementById('statErrors');
            
            if (statLetters) statLetters.textContent = results.completed;
            if (statCards) statCards.textContent = results.completed;
            if (statErrors) statErrors.textContent = results.errors;
        }
        
        // Initialize event listeners after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Handle PDF checkbox - enable/disable based on Documents checkbox
            const generateDocumentsCheckbox = document.getElementById('generateDocumentsCheckbox');
            const generatePdfCheckbox = document.getElementById('generatePdfCheckbox');
            const pdfCheckboxGroup = document.getElementById('pdfCheckboxGroup');
            const createTrelloCheckbox = document.getElementById('createTrelloCheckbox');
            
            // Helper function to validate and show/hide validation message
            function updateValidationMessage() {
                const createTrello = createTrelloCheckbox ? createTrelloCheckbox.checked : false;
                const generateDocuments = generateDocumentsCheckbox ? generateDocumentsCheckbox.checked : false;
                const validationMsg = document.getElementById('validationMessage');
                
                if (validationMsg) {
                    if (!createTrello && !generateDocuments) {
                        validationMsg.style.display = 'block';
                    } else {
                        validationMsg.style.display = 'none';
                    }
                }
            }
            
            if (generateDocumentsCheckbox && generatePdfCheckbox && pdfCheckboxGroup) {
                // Update PDF checkbox state when Documents checkbox changes
                generateDocumentsCheckbox.addEventListener('change', function() {
                    if (this.checked) {
                        // Enable PDF checkbox
                        generatePdfCheckbox.disabled = false;
                        pdfCheckboxGroup.style.opacity = '1';
                        pdfCheckboxGroup.style.pointerEvents = 'auto';
                    } else {
                        // Disable PDF checkbox and uncheck it
                        generatePdfCheckbox.disabled = true;
                        generatePdfCheckbox.checked = false;
                        pdfCheckboxGroup.style.opacity = '0.5';
                        pdfCheckboxGroup.style.pointerEvents = 'none';
                    }
                    // Check validation state
                    updateValidationMessage();
                });
                
                // Check validation when Trello checkbox changes
                if (createTrelloCheckbox) {
                    createTrelloCheckbox.addEventListener('change', function() {
                        updateValidationMessage();
                    });
                }
                
                // Handle LLM dropdown - enable/disable based on Documents checkbox
                const llmSelect = document.getElementById('llmSelect');
                if (llmSelect && generateDocumentsCheckbox) {
                    generateDocumentsCheckbox.addEventListener('change', function() {
                        if (this.checked) {
                            // Enable LLM dropdown
                            llmSelect.disabled = false;
                            llmSelect.style.opacity = '1';
                            llmSelect.style.pointerEvents = 'auto';
                        } else {
                            // Disable LLM dropdown
                            llmSelect.disabled = true;
                            llmSelect.style.opacity = '0.5';
                            llmSelect.style.pointerEvents = 'none';
                        }
                    });
                    
                    // Set initial state
                    if (!generateDocumentsCheckbox.checked) {
                        llmSelect.disabled = true;
                        llmSelect.style.opacity = '0.5';
                        llmSelect.style.pointerEvents = 'none';
                    }
                }
                
                // Set initial state for PDF
                if (!generateDocumentsCheckbox.checked) {
                    generatePdfCheckbox.disabled = true;
                    pdfCheckboxGroup.style.opacity = '0.5';
                    pdfCheckboxGroup.style.pointerEvents = 'none';
                }
                
                // Initial validation check
                updateValidationMessage();
            }
            
            // Count URLs
            const urlInput = document.getElementById('urlInput');
            if (urlInput) {
                urlInput.addEventListener('input', function() {
                    const urls = this.value.trim().split('\n').filter(url => url.trim().length > 0);
                    document.getElementById('urlCount').textContent = urls.length;
                });
                
                // Allow Enter to submit in URL input
                urlInput.addEventListener('keydown', function(e) {
                    if (e.ctrlKey && e.key === 'Enter') {
                        processAllJobs();
                    }
                });
            }
        });
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadRecentFiles();
            // Refresh recent files every 5 seconds while processing
            setInterval(function() {
                if (processing) loadRecentFiles();
            }, 5000);
        });
        
        // Load recent files from API
        async function loadRecentFiles() {
            try {
                const response = await fetch('/api/recent-files?limit=10');
                const data = await response.json();
                displayRecentFiles(data.files);
            } catch (error) {
                console.error('Error loading recent files:', error);
            }
        }
        
        // Display recent files in the UI
        function displayRecentFiles(files) {
            const container = document.getElementById('recentFilesList');
            
            if (files.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding: 20px 0;">
                        <div class="empty-state-text">No files generated yet</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = files.map(file => {
                const date = new Date(file.time * 1000);
                const timeAgo = getTimeAgo(date);
                const fileName = file.name.length > 45 ? file.name.substring(0, 42) + '...' : file.name;
                
                return `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-name" title="${file.name}">${fileName}</div>
                            <div class="file-time">${timeAgo}</div>
                        </div>
                        <a href="/download/${file.path}" class="file-download" download>‚¨á</a>
                    </div>
                `;
            }).join('');
        }
        
        // Helper: time ago formatter
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }
    </script>
</body>
</html>



